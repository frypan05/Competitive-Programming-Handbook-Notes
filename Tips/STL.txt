header files help us to use certain:
Algorithms, Containers, Functions, Iterators =  inside our program for the ease of use.

<strings> is used as a single library header.
<strings.h> is used to include all the algorithms and functions inside the strings library.


What is the difference b/w void and int/double/string, etc. ?

void print(){
    cout << "daksh";
}
// This has no return statement.

int sum(int a, int b){
    return a+b;
}

int main(){
    print();
    int s = sum(1,5);
    cout << s;
    return 0;
}


PAIRS:

void explainPairs(){
    pair <int, int> p = {1,2};
    cout << p.first << p.second;

    pair <int, pair <int, int>> p1 = {1, {2,3}};
    cout << p.first << p.second.second << p.second.first;
    // prints 1 3 2

    pair <int, int> arr[] = { {1,2}, {2,5}, {3,6} };
    cout << arr[1].second;
    //prints: 5
}

VECTORS:

void explainVectors(){
    // vector is a dynamic array provided by the C++ Standard Library.
    // It manages its own memory, keeps elements contiguous (like a C-array),
    // and automatically grows as you add elements.
    vector<int> v = {1, 2, 3}; // initializer list
    v.push_back(4); // add element at the end

    v.emplace_back(5); // add element at the end (Its faster than push_back)

    cout << "Elements:";
    for(int x : v) cout << ' ' << x; // range-for iteration
    cout << '\n';

    // Size and capacity
    cout << "size: " << v.size();       // number of elements
    cout << " capacity: " << v.capacity() << '\n'; // allocated storage

    // Random access (O(1))
    cout << "v[1]: " << v[1];          // no bounds check
    cout << " v.at(1): " << v.at(1) << '\n'; // at() throws exception on out-of-range

    // Useful operations
    v.pop_back();       // remove last element
    v.insert(v.begin() + 1, 10); // insert at position (O(n) cost)
    v.erase(v.begin()); // erase first element (O(n) cost)

    // Resize / reserve
    v.reserve(100); // ensure capacity for 100 elements to avoid reallocations
    v.resize(5);    // change logical size (adds default-inserted elements if larger)

    // Convert from C-array
    int arr[] = {7,8,9};
    vector<int> v2(begin(arr), end(arr));

    // Vector of vectors (2D-like)
    vector<vector<int>> grid = { {1,2}, {3,4,5} };
    grid[0].push_back(6);

    // When to choose vectors over raw arrays:
    // - You need a dynamic-size container (arrays have fixed size).
    // - You want automatic memory management (no manual new/delete).
    // - You want standard conveniences: size(), iterators, algorithms compatibility.
    // - Vectors are contiguous, so you can still use &v[0] or v.data() for C APIs.
    // Note: push_back is amortized O(1), random access is O(1); inserting/removing
    // in the middle is O(n).

    cout << "final size: " << v.size() << '\n';
}



========================================================================

vector<int> v3(5, 100);
-> here, 5 is for the indexing, with values 100
{ 100, 100, 100, 100, 100 }
-> we can also use just 5 to put in 5 elements without allocating any values.
{ 0, 0, 0, 0, 0 }



NOW ITERATORS:

dataStructure<dataType>::iterator name = .begin();

ex: vector<int>::iterator it = v.begin();
it++;
cout << *(it) << " ";


==> The iterators points to the elements of the vector./ to a certain garbage value for its memory allocation.
(Points directly to the memory of the elements and not the elements themselves.)
==> To iterate through array and vectors, we must use iterators.

v.begin();
v.end();  ===> this points just right outside the vector, in order to get the lsat element, we must do it--;
v.rend(); reverse end.
v.rbegin(); if we put it++ then it will reverse traverse the vector.

STL LIBRARY AUTO FUNCTION:
==========================

auto a = 5;
Here, auto defines the datatype by itself to integer.
auto b = "Hey";
Here, auto defines the datatype by itself to string.

DELETE FUNCTION (erase();)

v.erase(v.begin()+ 1);

===============
LIST CONTAINER:
===============

list<int> ls;
ls.push_back(2);
ls.emplace_back(4);

ls.push_front(5);
ls.emplace_front(6);

==============================================
STACK CONTAINER: [ LIFO ] - [PUSH | POP | TOP]
==============================================

stack<int> st;
st.push(1);
st.push(2);
st.push(3);

cout << st.top() << endl;
st.pop();
cout << st.top() << endl;

================================================
QUEUE CONTAINER: [ FIFO ] - [PUSH | POP | FRONT]
================================================
queue<int> q;
q.push(1);
q.push(2);
q.push(4);
q.back() += 5; // the 4 becomes 9.

cout << q.front() << endl; //prints 1
q.pop();
cout << q.front() << endl; //prints 2

===========================================================
PRIORITY QUEUE CONTAINER: [ MAX HEAP ] - [PUSH | POP | TOP]
===========================================================
Largest string/int stays at the top.
priority_queue<int> pq;
pq.push(1);
pq.push(2);
pq.push(4);
pq.push(5);

cout << pq.top() << endl; //prints 5
pq.pop();
cout << pq.top() << endl; //prints 4

==============
SET CONTAINER:
==============
stores in a sorted as well as unique manner.

set<int> s;
s.insert(1);
s.insert(2);
s.insert(3);

auto it = s.find(2); // it returns an iterator that points to the element 2.

if(it != s.end()) {
    cout << "Found" << endl;
}
int cnt = s.count(2); // it returns the number of elements with the value 2.

set<int> s1 = {1, 2, 3, 4};
set<int> s2 = {3, 4, 5, 6};

set<int> s3;
s3 = s1 & s2; // intersection
s3 = s1 | s2; // union
s3 = s1 - s2; // difference
