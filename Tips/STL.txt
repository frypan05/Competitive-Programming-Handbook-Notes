header files help us to use certain:
Algorithms, Containers, Functions, Iterators =  inside our program for the ease of use.

<strings> is used as a single library header.
<strings.h> is used to include all the algorithms and functions inside the strings library.


What is the difference b/w void and int/double/string, etc. ?

void print(){
    cout << "daksh";
}
// This has no return statement.

int sum(int a, int b){
    return a+b;
}

int main(){
    print();
    int s = sum(1,5);
    cout << s;
    return 0;
}


PAIRS:

void explainPairs(){
    pair <int, int> p = {1,2};
    cout << p.first << p.second;

    pair <int, pair <int, int>> p1 = {1, {2,3}};
    cout << p.first << p.second.second << p.second.first;
    // prints 1 3 2

    pair <int, int> arr[] = { {1,2}, {2,5}, {3,6} };
    cout << arr[1].second;
    //prints: 5
}

VECTORS:

void explainVectors(){
    // vector is a dynamic array provided by the C++ Standard Library.
    // It manages its own memory, keeps elements contiguous (like a C-array),
    // and automatically grows as you add elements.
    vector<int> v = {1, 2, 3}; // initializer list
    v.push_back(4); // add element at the end

    cout << "Elements:";
    for(int x : v) cout << ' ' << x; // range-for iteration
    cout << '\n';

    // Size and capacity
    cout << "size: " << v.size();       // number of elements
    cout << " capacity: " << v.capacity() << '\n'; // allocated storage

    // Random access (O(1))
    cout << "v[1]: " << v[1];          // no bounds check
    cout << " v.at(1): " << v.at(1) << '\n'; // at() throws exception on out-of-range

    // Useful operations
    v.pop_back();       // remove last element
    v.insert(v.begin() + 1, 10); // insert at position (O(n) cost)
    v.erase(v.begin()); // erase first element (O(n) cost)

    // Resize / reserve
    v.reserve(100); // ensure capacity for 100 elements to avoid reallocations
    v.resize(5);    // change logical size (adds default-inserted elements if larger)

    // Convert from C-array
    int arr[] = {7,8,9};
    vector<int> v2(begin(arr), end(arr));

    // Vector of vectors (2D-like)
    vector<vector<int>> grid = { {1,2}, {3,4,5} };
    grid[0].push_back(6);

    // When to choose vectors over raw arrays:
    // - You need a dynamic-size container (arrays have fixed size).
    // - You want automatic memory management (no manual new/delete).
    // - You want standard conveniences: size(), iterators, algorithms compatibility.
    // - Vectors are contiguous, so you can still use &v[0] or v.data() for C APIs.
    // Note: push_back is amortized O(1), random access is O(1); inserting/removing
    // in the middle is O(n).

    cout << "final size: " << v.size() << '\n';
}
